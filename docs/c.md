<!--- This file is auto-generated by `make catalog`. Do not edit manually. -->

![Image of the c command execution](img/c.jpg)

* * *
# NAME

C - The Flat Text Calculator

# DESCRIPTION

The **c** script displays the result of the given expression.

# SYNOPSIS

$ c \[_OPTIONS..._\] _EXPRESSIONS_

# EXPRESSIONS

## OPERANDS

### Decimal:

0, -1, 100 ...

### Hexadecimal:

0xf, -0x1, 0x0064 ...

### Constant:

- PI

    3.14159265358979

- NOW

    CURRENT-TIME

- User-defined-file

    ".c.rc" should be placed in the same directory as "c script" or in "$HOME".

        [ .c.rc ]
        ## - ".c.rc" should be placed
        ##   in the same directory as "c script" or in "$HOME".
        ##
        ## - "c script" is not case-sensitive.
        ## - All keys are converted to lowercase.
        ## - If you create definitions with different case,
        ##   they will be overwritten by definitions loaded later.

        my %user_constant;

        ## ex.) $ c 'geo_distance_km( MADAGASCAR_COORD, GALAPAGOS_ISLANDS_COORD )'
        ##      14907.357977036
        $user_constant{MADAGASCAR_COORD} = 'deg2rad( -18.76694, 46.8691 )';
        $user_constant{GALAPAGOS_ISLANDS_COORD} = 'deg2rad( -0.3831, -90.42333 )';

        $user_constant{GOLDEN_RATIO} = '( ( 1 + sqrt( 5 ) ) / 2 )'; # 1.61803398874989

        return %user_constant;

## OPERATORS

\+ - \* / % \*\* | & ^ << >> ~ ( , ) =

## FUNCTIONS

abs, int, floor, ceil, rounddown, round, roundup, percentage, ratio\_scaling, is\_prime, prime\_factorize, get\_prime, gcd, lcm, ncr, min,
max, shuffle, first, slice, uniq, sum, prod, avg, add\_each, mul\_each, linspace, linstep, mul\_growth, gen\_fibo\_seq, paper\_size, rand, exp,
exp2, exp10, log, log2, log10, sqrt, pow, pow\_inv, rad2deg, deg2rad, dms2rad, dms2deg, deg2dms, dms2dms, sin, cos, tan, asin, acos, atan,
atan2, hypot, angle\_deg, dist\_between\_points, midpt\_between\_points, angle\_between\_points, geo\_radius, radius\_of\_lat, geo\_distance,
geo\_distance\_m, geo\_distance\_km, geo\_azimuth, geo\_dist\_m\_and\_azimuth, geo\_dist\_km\_and\_azimuth, is\_leap, age\_of\_moon, local2epoch, gmt2epoch,
epoch2local, epoch2gmt, sec2dhms, dhms2sec, ri2meter, meter2ri, mile2meter, meter2mile, nautical\_mile2meter, meter2nautical\_mile,
pound2gram, gram2pound, ounce2gram, gram2ounce, laptimer, timer, stopwatch, bpm, bpm15, bpm30, tachymeter, telemeter, telemeter\_m,
telemeter\_km

# OPTIONS

- -d, --debug

        Enable debug output.

- -v, --verbose

        The intermediate steps of the calculation will also be displayed.

- -r, --rpn

        The expression will be displayed in Reverse Polish Notation,
        but the calculation result will not be shown.

        If you want to display the calculation result,
        please use the --verbose option as well.

- -u, --user-defined

    Outputs a list of user-defined values ​​defined in ".c.rc".

- --version

    Print the version of this script and Perl and exit.

- -h, --help

        Display simple help and exit.

# ADVANCED USAGE

## BASIC USE CASE

When you provide a calculation formula, it will display the result.

    $ c 123456-59+123.456*2=
    123643.912

Use parentheses if you want to control the order of operations.

    $ c '123456-(59+123.456)*2='
    123091.088

Using the _-v_ or _--verbose_ option will display the intermediate calculations as well.

    $ c 123456-59+123.456*2= -v
    123456 - 59 = 123397
    123.456 * 2 = 246.912
    123397 + 246.912 = 123643.912
    Formula: '123456 - 59 + 123.456 * 2 ='
        RPN: '123456 59 - 123.456 2 * +'
     Result: 123643.912

You can also specify calculation formulas written in UTF-8.

    $ c １２３，４５６－５９ ＋ １２３．４５６＊２＝
    123643.912

If you simply want to format a mathematical formula that you found on the web,
please use the _-v_ or _--verbose_ option switch.

    $ c '２ ＰＩ １０＝' --verbose
    2 * 3.14159265358979 = 6.28318530717958
    6.28318530717958 * 10 = 62.8318530717958
    Formula: '2 * 3.14159265358979 * 10 ='    <--- HERE
        RPN: '2 3.14159265358979 * 10 *'
     Result: 62.8318530717958

Several functions are also available.

    $ c 'sqrt( power( 1920, 2 ) + power( 1080, 2 ) ) ='
    2202.9071700823

Example of using the functions.

What combinations involve choosing 4 out of 6 ?

    $ c 'nCr( 6, 4 )'
    15

Alternative Method

    $ c 'prod( linstep( 6, -1, 4 ) ) / prod( linstep( 4, -1, 4 ) )' -v
    linstep( 6, -1, 4 ) = ( 6, 5, 4, 3 )
    prod( 6, 5, 4, 3 ) = 360
    linstep( 4, -1, 4 ) = ( 4, 3, 2, 1 )
    prod( 4, 3, 2, 1 ) = 24
    360 / 24 = 15
    Formula: 'prod( linstep( 6, -1, 4 ) ) / prod( linstep( 4, -1, 4 ) ) ='
        RPN: '# # 6 -1 4 linstep prod # # 4 -1 4 linstep prod /'
     Result: 15

The candidate values ​​are 10 equally spaced values ​​from 0 to 90 degrees,
and the radians of an arbitrarily selected value are calculated.

    $ c 'deg2rad( first( shuffle( linspace( 0, 90, 10 ) ) ) )' -v
    linspace( 0, 90, 10 ) = ( 0, 10, 20, 30, 40, 50, 60, 70, 80, 90 )
    shuffle( 0, 10, 20, 30, 40, 50, 60, 70, 80, 90 ) = ( 10, 80, 60, 40, 30, 90, 50, 70, 20, 0 )
    first( 10, 80, 60, 40, 30, 90, 50, 70, 20, 0 ) = 10
    deg2rad( 10 ) = 0.174532925199433
    Formula: 'deg2rad( first( shuffle( linspace( 0, 90, 10 ) ) ) ) ='
        RPN: '# # # # 0 90 10 linspace shuffle first deg2rad'
     Result: 0.174532925199433

If you specify the operands in hexadecimal or use bitwise operators,
the calculation result will also be displayed in hexadecimal.

    # Bitwise AND
    $ c '0xfc & 0x3f'
    60 [ = 0x3C ]

    # Bitwise OR
    $ c '0xfc | 0x3f'
    255 [ = 0xFF ]

    # Bitwise Exclusive OR
    $ c '0xfc ^ 0x3f'
    195 [ = 0xC3 ]

    # Bitwise left shift
    $ c '0x3c << 1'
    120 [ = 0x78 ]

    # Bitwise right shift
    $ c '0x3c >> 1'
    30 [ = 0x1E ]

    # Bitwise Inversion
    $ c '~0x1 & 0x3f'
    62 [ = 0x3E ]

There is no option switch to display the calculation results in hexadecimal.
However, you can display it by performing a bitwise '_|\[OR\]_' operation with 0.

    $ c '100|0'
    100 [ = 0x64 ]

\[ radical (of n) \] Eliminate duplicates of each prime factor and take the product:

    ## Factorize any given number into prime factors...
    $ c 'prime_factorize( 4428 )'
    ( 2, 2, 3, 3, 3, 41 )

    ## Eliminate duplicates...
    $ c 'uniq( prime_factorize( 4428 ) )'
    ( 2, 3, 41 )

    ## Take the product of each value
    $ c 'prod( uniq( prime_factorize( 4428 ) ) )'
    246

You can also:

    ## Generate prime numbers in 16-bit width
    $ c 'prod( get_prime( 16 ), get_prime( 16 ) )'
    1691574281

    ## check
    $ c 'pf( 1691574281 )|0'  ## pf() is an alias for prime_factorize().
    ( 29303, 57727 ) [ = ( 0x7277, 0xE17F ) ]

## STANDARD INPUT (STDIN) MODE

If no calculation formula is specified as an argument,
the program will wait for input from STDIN.
To exit, send an End Of File signal (for example, press Ctrl + D).

    $ c
    ^D

Example of running with the _-v_ or _--verbose_ option:

    $ c --verbose
    0.22*10**(-6)=    <-- INPUT FROM KEYBOARD
    10 ** -6 = 1e-06
    0.22 * 1e-06 = 2.2e-07
    Formula: '0.22 * 10 ** ( -6 ) ='
        RPN: '0.22 10 -6 ** *'
     Result: 0.00000022 [ = 2.2e-07 ]
    <-- INPUT FROM KEYBOARD

    sqrt(2)=    <-- INPUT FROM KEYBOARD
    sqrt( 2 ) = 1.4142135623731
    Formula: 'sqrt( 2 ) ='
        RPN: '# 2 sqrt'
     Result: 1.4142135623731
    ^D    <-- INPUT FROM KEYBOARD

By constructing the calculation formula first,
you can easily repeat similar calculations.
For example, when using **sed**:

    $ cat - | sed -u 's/^\(.*\)$/round( (\1+0) * 1.1 , 0 ) =/'
    1028    <-- INPUT FROM KEYBOARD
    round( (1028+0) * 1.1 , 0 ) =
    <-- INPUT FROM KEYBOARD
    round( (+0) * 1.1 , 0 ) =
    ^D    <-- INPUT FROM KEYBOARD

The formula looks fine, so let's pipe it into the _c_ script:

    $ !! | c
    cat - | sed -u 's/^\(.*\)$/round( (\1+0) * 1.1 , 0 ) =/' | c
    1000
    1100    <-- RESULT
    500
    550     <-- RESULT
    998
    1098    <-- RESULT
    ^D

It might be convenient to register it as an alias:

    ex.) ~/.bashrc
    alias ctax="cat - | sed -u 's/^\(.*\)$/round( (\1+0) * 1.1 , 0 ) =/' | c"

## TIME CALCULATIONS

Current time in seconds since the epoch:

    $ c now
    1764003197

In an easy-to-understand format:

    $ c 'epoch2local( now )'
    ( 2025, 11, 25, 1, 53, 17 )   # 2025-11-25 01:53:17

Time elapsed since a specified date:

    $ c 'sec2dhms( now - local2epoch( 2011, 03, 11, 14, 46 ) )'
    ( 5372, 15, 51, 18 )  # 5372 days, 15 hours, 51 minutes, and 18 seconds

1 hour and 45 minutes before two days later:

    $ c 'epoch2local( local2epoch( 2020, 1, 1, 15, 0, 0 ) + dhms2sec( 2, -1, -45 ) )'
    ( 2020, 1, 3, 13, 15, 0 ) # Jan. 3, 2020 at 13:15:00.

If it takes 1 hour and 18 minutes to make 3, when will 15 be completed?:

    $ c 'epoch2local(
           local2epoch( 2025, 11, 25, 09, 00 ) +
           ratio_scaling( 3, dhms2sec( 0, 1, 18 ), 15 )
         )'
    ( 2025, 11, 25, 15, 30, 0 )   # Pace to complete on Nov. 25, 2025 at 15:30:00.

## COORDINATE CALCULATION

I think this is a feature that anyone who likes looking at maps will want to use.

Here we use the following coordinates (latitude and longitude):

    ex)
    Madagascar:        degrees: -18.76694, 46.8691
    Galapagos Islands: degrees: -0.3831, -90.42333

Calculate the distance between two points.

    $ c 'geo_distance_km(
           deg2rad( -18.76694, 46.8691 ),
           deg2rad( -0.3831, -90.42333 )
         ) ='
    14890.6974607313  # 14891 km

The straight-line distance between Madagascar and the Galapagos Islands was found to be 14,907 km.

If you want to specify latitude and longitude in DMS, use dms2rad().
Be sure to include the sign if the value is negative.

    # gd_km() is an alias for geo_distance_km().
    $ c 'gd_km(
           dms2rad( -18, -46,  -0.984000000006233 ), dms2rad( 46, 52, 8.76000000001113 ),
           dms2rad(  -0, -22, -59.16 ), dms2rad( -90, -25, -23.9880000000255 ) ) ='
    14890.6974607313  # 14891 km

The direction can also be calculated.

    $ c 'geo_azimuth( deg2rad( -18.76694, 46.8691, -0.3831, -90.42333 ) )'
    250.3084344602    # About west-southwest ( WSW )

It may be more intuitive to represent the direction as a value from 0 to 4 (N-E-S-W) rather than 0 to 360 degrees.

    $ c 'ratio_scaling(
           360,
           geo_azimuth( deg2rad( -18.76694, 46.8691, -0.3831, -90.42333 ) ),
           4
         )'
    2.78120482733556  # Direction Index (2.78 is between South(2) and West(3), closer to West)
                      # Approx: West-Southwest (WSW)

If you record the calculation as shown below,
you can save not only the calculation results but also the calculation method,
which I think will be easy to reuse and convenient.
This is one of the reasons why I wrote this tool.

Calculates distance and direction simultaneously.

    $ Madagascar_coord='-18.76694, 46.8691'
    $ Galapagos_Islands_coord='-0.3831, -90.42333'
    $ c "gd_km_azm(
           deg2rad(
             $Madagascar_coord, $Galapagos_Islands_coord
           )
         )"
    ( 14890.6974607313, 250.3084344602 )  # Dist: 14891 km, Brg: 250 degrees (WSW)
    $

The **c** script was created with the following in mind:

\- It will run with just Perl.

\- The calculation formulas are easy to understand even when read later.

# OPERATORS

- `+`

    Addition.
    `1 + 2` -> `3`.

- `-`

    Subtraction.
    `3 - 2` -> `1`.

- `*`

    Multiplication.
    `1 * 2` -> `2`.

- `/`

    Division.
    `1 / 2` -> `0.5`.

- `%`

    Modulo arithmetic.
    `5 % 3` -> `2`.

- `**`

    Exponentiation.
    `2 ** 3` -> `8`. Similarly, `pow( 2, 3 )`.

- `|`

    Bitwise OR.
    `0x2 | 0x4` -> `6 [ = 0x6 ]`.

- `&`

    Bitwise AND.
    `0x6 & 0x4` -> `4 [ = 0x4 ]`.

- `^`

    Bitwise Exclusive OR.
    `0x6 ^ 0x4` -> `2 [ = 0x2 ]`.

- `<<`

    Bitwise left shift.
    `0x6 << 1` -> `12 [ = 0xC ]`.

- `>>`

    Bitwise right shift.
    `0x6 >> 1` -> `3 [ = 0x3 ]`.

- `~`

    Bitwise Inversion.
    `~0` -> `0xFFFFFFFFFFFFFFFFFF`.

- `(`

    A symbol that controls the priority of calculations.

- `,`

    The separator that separates function arguments.

- `)`

    A symbol that controls the priority of calculations.

- `=`

    Equals sign.
    In _c_ script, it has the meaning of terminating the calculation formula,
    but it is not necessary.
    `1 + 2 =`.
    Similarly, `1 + 2`.

# FUNCTIONS

- `abs`

    abs( _N1_ \[,.. \] ).
    Returns the absolute value of its argument.
    \[Perl Native\]

        $ c 'abs( -1.2, 1.2 )'
        ( 1.2, 1.2 )

- `int`

    int( _N1_ \[,.. \] ).
    Returns the integer portion of _N_.
    \[Perl Native\]

        $ c 'int( -1.2, 1.2 )'
        ( -1, 1 )

- `floor`

    floor( _N1_ \[,.. \] ).
    Returning the largest integer value less than or equal to the numerical argument.
    \[POSIX\]

        $ c 'floor( -1.2, 1.2 )'
        ( -2, 1 )

- `ceil`

    ceil( _N1_ \[,.. \] ).
    Returning the smallest integer value greater than or equal to the given numerical argument.
    \[POSIX\]

        $ c 'ceil( -1.2, 1.2 )'
        ( -1, 2 )

- `rounddown`

    rounddown( _NUMBER1_ \[ ,.. \], _DECIMAL\_PLACES_ ).
    Returns the value of _NUMBER1_ truncated to _DECIMAL\_PLACES_.

        $ c 'rounddown( -1.2, 1.2, 0 )'
        ( -1, 1 )

- `round`

    round( _NUMBER1_ \[ ,.. \], _DECIMAL\_PLACES_ ).
    Returns the value of _NUMBER1_ rounded to _DECIMAL\_PLACES_

        $ c 'round( -1.4, -1.5, 1.4, 1.5, 0 )'
        ( -1, -2, 1, 2 )

- `roundup`

    roundup( _NUMBER1_ \[ ,.. \], _DECIMAL\_PLACES_ ).
    Returns the value of _NUMBER1_ rounded up to _DECIMAL\_PLACES_.

        $ c 'roundup( -1.2, 1.2, 0 )'
        ( -2, 2 )

- `percentage`

    percentage( _NUMERATOR_, _DENOMINATOR_ \[, _DECIMAL\_PLACES_ \] ).
    Returns the percentage, rounding the number if _DECIMAL\_PLACES_ is specified.
    alias: pct().

        $ c 'percentage( 1, 6 )'
        16.6666666666667
        $ c 'percentage( 1, 6, 2 )'
        16.67

- `ratio_scaling`

    ratio\_scaling( _A_, _B_, _C_ \[, _DECIMAL\_PLACES_ \] ).
    When _A_:_B_, return the value of _X_ in _A_:_B_=_C_:_X_.
    Rounding the number if _DECIMAL\_PLACES_ is specified.
    alias: rs().

    If it takes 66 seconds to make 5 units, what will be the production quantity after 3600 seconds (1 hour)?:

        $ c 'ratio_scaling( 66, 5, 3600 )'
        272.727272727273
        $ c 'ratio_scaling( 66, 5, 3600, 1 )'
        272.7

- `is_prime`

    is\_prime( _NUM1_ \[,.. \] ).
    Prime number test.
    Returns 1 if _NUM_ is prime, otherwise returns 0.

        $ c 'is_prime( 1576770818 )'
        0
        $ c 'is_prime( 1576770817 )'
        1

- `prime_factorize`

    prime\_factorize( _NUM_ ).
    Do prime factorization. _NUM_ is an integer greater than or equal to 2.
    alias: pf().

        $ c 'prime_factorize( 1576770818 )'
        ( 2, 7, 112626487 )

        $ c 'prime_factorize( 1576770817 )'
        1576770817

- `get_prime`

    get\_prime( _BIT\_WIDTH_ ).
    Returns a random prime number within the range of _BIT\_WIDTH_,
    where _BIT\_WIDTH_ is an integer between 4 and 32, inclusive.

        $ c 'get_prime( 32 )'
        1576770817

- `gcd`

    gcd( _NUMBER1_,.. ).
    Returns the greatest common divisor (GCD),
    which is the largest positive integer that divides each of the operands.
    \[Math::BigInt::bgcd()\]

        $ c 'gcd( 402, 670, 804 )'
        134

- `lcm`

    lcm( _NUMBER1_,.. ).
    Returns the least common multiple (LCM).
    \[Math::BigInt::blcm()\]

        $ c 'lcm( 402, 670, 804 )'
        4020

- `ncr`

    nCr( _N_, _R_ ).
    _N_ Choose _R_. A combination of _R_ items selected from _N_ items.
    _N_ is a non-negative integer.
    _R_ is a positive integer.

    Number of combinations of choosing 3 out of 5:

        $ c 'nCr( 5, 3 )'
        10

- `min`

    min( _NUMBER1_,.. ).
    Returns the entry in the list with the lowest numerical value.
    \[List::Util\]

        $ c 'min( 402, 670, 804 )'
        402

- `max`

    max( _NUMBER1_,.. ).
    Returns the entry in the list with the highest numerical value.
    \[List::Util\]

        $ c 'max( 402, 670, 804 )'
        804

- `shuffle`

    shuffle( _NUMBER1_,.. ).
    Returns the values of the input in a random order.
    \[List::Util\]

        $ c 'shuffle( 402, 670, 804 )'
        ( 804, 402, 670 )

- `first`

    first( _NUMBER1_,.. ).
    Returns the head of the set.
    Same as slice( _NUMBER1_,.. , 0, 1 ).

        $ c 'first( 402, 670, 804 )'
        402

- `slice`

    slice( _NUMBER1_,.., _OFFSET_, _LENGTH_ ).
    Extracts elements specified by _OFFSET_ and _LENGTH_ from a set.

    Extract only the date (first three):

        $ c 'slice( ( 2025, 12, 17, 22, 13, 14 ), 0, 3 )'
        ( 2025, 12, 17 )

- `uniq`

    uniq( _NUMBER1_,.. ).
    Filters a list of values to remove subsequent duplicates,
    as judged by a DWIM-ish string equality or "undef" test.
    Preserves the order of unique elements, and retains the first value of any duplicate set.
    \[List::Util\]

        $ c 'uniq( 2, 3, 2, 3, 67, 3 )'
        ( 2, 3, 67 )

- `sum`

    sum( _NUMBER1_,.. ).
    Returns the numerical sum of all the elements in the list.
    \[List::Util\]

        $ c 'sum( 1, 2, 3, 4 )'
        10

- `prod`

    prod( _NUMBER1_,.. ).
    Returns the product of each value.

        $ c 'prod( 1, 2, 3, 4 )'
        24

- `avg`

    avg( _NUMBER1_,.. ).
    Returns the average value of all elements in a list.

        $ c 'avg( 1, 2, 3, 4 )'
        2.5

- `add_each`

    add\_each( _NUMBER1_,.. , _DELTA_ ). Add each number.

        $ c 'add_each( 100, 200, -10 )'
        ( 90, 190 )

- `mul_each`

    mul\_each( _NUMBER1_,.. , _FACTOR_ ). Multiply each number.

        $ c 'mul_each( 100, 200, 2 )'
        ( 200, 400 )

    Estimate the size (pixels) of an A4 sheet of paper (millimeters) scanned at 300 dpi:

        $ c 'mul_each( 210, 297, ( 1 / 25.4 ) * 300 )'
        ( 2480.31496062992, 3507.87401574803 )

- `linspace`

    linspace( _START_, _END_, _LENGTH_ \[, _DECIMAL\_PLACES_ \] ).
    Generates a list of evenly spaced numbers from _START_ to _END_.
    Returns a sequence of numbers of size _LENGTH_.
    _LENGTH_ is an integer greater than or equal to 2.
    Rounding the number if _DECIMAL\_PLACES_ is specified.

    Divide the range from 0x33 to 0xCC into 5 parts:

        $ c 'linspace( 0x33, 0xcc, 5 )'
        ( 51, 89.25, 127.5, 165.75, 204 ) [ = ( 0x33, 89.25, 127.5, 165.75, 0xCC ) ]
        $ c 'linspace( 0x33, 0xcc, 5, 0 )'
        ( 51, 89, 128, 166, 204 ) [ = ( 0x33, 0x59, 0x80, 0xA6, 0xCC ) ]

- `linstep`

    linstep( _START_, _DELTA_, _LENGTH_ ).
    Generates a list of _LENGTH_ numbers that increase from _START_ by _DELTA_.
    Returns the sequence of numbers starting at _START_ and of size _LENGTH_.
    _LENGTH_ is an integer greater than or equal to 1.

    A sequence of 10 numbers that decrease by 2 from 101:

        $ c 'linstep( 101, -2, 10 )'
        ( 101, 99, 97, 95, 93, 91, 89, 87, 85, 83 )

- `mul_growth`

    mul\_growth( _START_, _FACTOR_, _LENGTH_ ).
    Starting from _START_, we multiply the value by _FACTOR_ and add it to the sequence.
    Returns the sequence of numbers starting at _START_ and of size _LENGTH_.
    _LENGTH_ is an integer greater than or equal to 1.

        $ c 'mul_growth( 100, 0.9, 8 )'
        ( 100, 90, 81, 72.9, 65.61, 59.049, 53.1441, 47.82969 )

- `gen_fibo_seq`

    gen\_fibo\_seq( _A_, _B_, _LENGTH_ ).
    Generates the Generalized Fibonacci Sequence.
    Returns the sequence of numbers starting at _A_, _B_ and of size _LENGTH_.
    _LENGTH_ is an integer greater than or equal to 2.

    Generate the Lucas sequence:

        $ c 'gen_fibo_seq( 2, 1, 10 )'
        ( 2, 1, 3, 4, 7, 11, 18, 29, 47, 76 )

- `paper_size`

    paper\_size( SIZE \[, TYPE \] ).
    Returns the following information in this order:
    length of short side, length of long side (in mm).
    SIZE is a non-negative integer.
    If TYPE is omitted or 0 is specified, it will be A size.
    If TYPE is specified as 1, it will be B size ( Japan's unique standards ).

    What are the dimensions of A4 size ?:

        $ c 'paper_size( 4 )'
        ( 210, 297 )  # Short: 210 mm, Long: 297 mm

    What are the dimensions of B4 size ?: ( B size is a standard unique to Japan )

        $ c 'paper_size( 4, 1 )'
        ( 257, 364 )  # Short: 257 mm, Long: 364 mm

    Area of ​​A5 size:

        $ c 'prod( paper_size( 5 ) )'
        31080         # Area: 31,080 mm2

- `rand`

    rand( _N_ ).
    Returns a random fractional number greater than or equal to 0 and less than the value of _N_.
    \[Perl Native\]

    A random number between 0 and 6:

        $ c 'rand( 6 )'
        4.11497904963291

    0 or 1 or 2 or 3 or 4 or 5:

        $ c 'int( rand( 6 ) )'
        2

- `exp`

    exp( _N1_ \[,.. \] ).
    Returns e (the natural logarithm base) to the power of _N_.
    \[Perl Native\]

    The base of natural logarithms e (Napier's constant):

        $ c 'exp( 1 )'
        2.71828182845905

- `log`

    log( _N1_ \[,.. \] ).
    Returns the natural logarithm (base e) of _N_.
    \[Perl Native\]

    exp(1) is the base of the natural logarithm ( Napier's constant ):

        $ c 'log( 100 )'
        4.60517018598809
        $ c 'exp( log( 100 ) )'
        100
        $ c 'pow( exp( 1 ), log( 100 ) )'
        100

    A product of antilogarithms is transformed into a sum of logarithms:

        $ c 'log( 200 * 300 )'
        11.0020998412042
        $ c 'log( 200 ) + log( 300 )'
        11.0020998412042

    The quotient of real numbers is the difference of logarithms:

        $ c 'log( 200 / 300 )'
        -0.405465108108164
        $ c 'log( 200 ) - log( 300 )'
        -0.405465108108165

    Antilogarithmic exponents are converted to constant multiples of the logarithm:

        $ c 'log( power( 200, 100 ) )'
        529.831736654804
        $ c '100 * log( 200 )'
        529.831736654804

    The reciprocal of an antilogarithm reverses the sign of the logarithm.

        $ c 'log( 1 / 100 )'
        -4.60517018598809
        $ c 'log( power( 100, -1 ) )'
        -4.60517018598809
        $ c '-1 * log( 100 )'
        -4.60517018598809

- `exp2`

    exp2( _N1_ \[,.. \] ).
    Returns the base 2 raised to the power N.

        $ c 'exp2( 8, 16, 32 )'
        ( 256, 65536, 4294967296 )

    The following three expressions are equivalent:

        $ c 'exp2( 10 )'
        1024
        $ c 'exp( 10 * log( 2 ) )'
        1024
        $ c 'pow( 2, 10 )'
        1024

- `log2`

    log2( _N1_ \[,.. \] ).
    Returns the common logarithm to the base 2.

        $ c 'log2( 256, 65536, 4294967296 )'
        ( 8, 16, 32 )

    The following three expressions are equivalent:

        $ c 'log2( 1024 )'
        10
        $ c 'log( 1024 ) / log( 2 )'
        10
        $ c 'pow_inv( 1024, 2 )'
        10

- `exp10`

    exp10( _N1_ \[,.. \] ).
    Returns the base 10 raised to the power N.

        $ c 'exp10( 1, 2, 3 )'
        ( 10, 100, 1000 )

    The following three expressions are equivalent:

        $ c 'exp10( 5 )'
        100000
        $ c 'exp( 5 * log( 10 ) )'
        100000
        $ c 'pow( 10, 5 )'
        100000

- `log10`

    log10( _N1_ \[,.. \] ).
    Returns the common logarithm to the base 10.

        $ c 'log10( 10, 100, 1000 )'
        ( 1, 2, 3 )

    The following three expressions are equivalent:

        $ c 'log10( 10000 )'
        4
        $ c 'log( 10000 ) / log( 10 )'
        4
        $ c 'pow_inv( 10000, 10 )'
        4

- `sqrt`

    sqrt( _N1_ \[,.. \] ).
    Return the positive square root of _N_.
    Works only for non-negative operands.
    \[Perl Native\]

        $ c 'sqrt( 9, 16, 25 )'
        ( 3, 4, 5 )

- `pow`

    pow( _A_, _B_ ).
    Exponentiation.
    "pow( 2, 3 )" -> 8.
    Similarly, "2 \*\* 3".
    \[Perl Native\]

        $ c 'pow( 2, 3 )'
        8

- `pow_inv`

    pow\_inv( _A_, _B_ ).
    Returns the power of _A_ to which _B_ is raised.

        $ c 'pow_inv( 8, 2 )'
        3

- `rad2deg`

    rad2deg( _RADIANS_ \[, _RADIANS_..\] ) -> ( _DEGREES_ \[, _DEGREES_..\] ).
    \[Math::Trig\]

        $ c 'rad2deg( 2.50620553940126 )'
        143.595

- `deg2rad`

    deg2rad( _DEGREES_ \[, _DEGREES_..\] ) -> ( _RADIANS_ \[, _RADIANS_..\] ).
    \[Math::Trig\]

        $ c 'deg2rad( 143.595 )'
        2.50620553940126

- `dms2rad`

    dms2rad( _DEG_, _MIN_, _SEC_ \[, _DEG_, _MIN_, _SEC_ ..\] ) -> ( _RADIANS_ \[, _RADIANS_..\] ).

        $ c 'dms2rad( 143, 35, 42.0000000000002 )'
        2.50620553940126

- `dms2deg`

    dms2deg( _DEG_, _MIN_, _SEC_ \[, _DEG_, _MIN_, _SEC_ ..\] ) -> ( _DEGREES_ \[, _DEGREES_..\] ).

        $ c 'dms2deg( 143, 35, 42.0000000000002 )'
        143.595

- `deg2dms`

    deg2dms( _DEGREES_ \[, _DEGREES_..\] ) -> ( _DEG_, _MIN_, _SEC_ \[, _DEG_, _MIN_, _SEC_ ..\] ).

        $ c 'deg2dms( 143.595 )'
        ( 143, 35, 41.9999999999959 )

- `dms2dms`

    dms2dms( _DEG_, _MIN_, _SEC_ \[, _DEG_, _MIN_, _SEC_ ..\] ) -> ( _DEG_, _MIN_, _SEC_ \[, _DEG_, _MIN_, _SEC_ ..\] ).

        $ c 'dms2dms( 143, 35.7, 0 )'
        ( 143, 35, 42.0000000000002 )

- `sin`

    sin( _RADIANS_ ).
    Returns the sine of _RADIANS_.
    \[Perl Native\]

- `cos`

    cos( _RADIANS_ ).
    Returns the cosine of _RADIANS_.
    \[Perl Native\]

- `tan`

    tan( _RADIANS_ ).
    Returns the tangent of _RADIANS_.
    \[Math::Trig\]

- `asin`

    asin( _RATIO_ ).
    The arcus (also known as the inverse) functions of the sine.
    \[Math::Trig\]

        $ c 'rad2deg( asin( 1 / 2 ) )'
        30

- `acos`

    acos( _RATIO_ ).
    The arcus (also known as the inverse) functions of the cosine.
    \[Math::Trig\]

        $ c 'rad2deg( acos( 1 / 2 ) )'
        60

- `atan`

    atan( _RATIO_ ).
    The arcus (also known as the inverse) functions of the tangent.
    \[Math::Trig\]

        $ c 'rad2deg( atan( 1 / 1 ) )'
        45

- `atan2`

    atan2( _Y_, _X_ ).
    The principal value of the arc tangent of _Y_ / _X_.
    \[Math::Trig\]

        $ c 'rad2deg( atan2( 1, 1 ) )'
        45

- `hypot`

    hypot( _X_, _Y_ ).
    Equivalent to "sqrt( _X_ \* _X_ + _Y_ \* _Y_ )" except more stable on very large or very small arguments.
    \[POSIX\]

        $ c 'hypot( 3, 4 )'
        5

- `angle_deg`

    angle\_deg( _X_, _Y_ \[, _IS\_AZIMUTH_ \] ).
    Returns the straight line distance from (0,0) to (_X_,_Y_).
    Returns the standard mathematical angle (0 degrees = east, counterclockwise).
    If _IS\_AZIMUTH_ is set to true, returns the angle (0 degrees = north, clockwise).

        $ c 'angle_deg( 3, 4 )'
        53.130102354156

- `dist_between_points`

    dist\_between\_points( _X1_, _Y1_, _X2_, _Y2_ ) or dist\_between\_points( _X1_, _Y1_, _Z1_, _X2_, _Y2_, _Z2_ ).
    Returns the straight-line distance from (_X1_,_Y1_) to (_X2_,_Y2_) or from (_X1_,_Y1_,_Z1_) to (_X2_,_Y2_,_Z2_).
    alias: dist().

        $ c 'dist_between_points( 100, 10, 200, 110 )'
        141.42135623731

        $ c 'dist_between_points( 100, 10, 50, 200, 110, 150 )'
        173.205080756888

- `midpt_between_points`

    midpt\_between\_points( _X1_, _Y1_, _X2_, _Y2_ ) or midpt\_between\_points( _X1_, _Y1_, _Z1_, _X2_, _Y2_, _Z2_ ).
    Returns the coordinates of the midpoint between (_X1_,_Y1_) and (_X2_,_Y2_), or (_X1_,_Y1_,_Z1_) and (_X2_,_Y2_,_Z2_).
    alias: midpt().

        $ c 'midpt_between_points( 100, 10, 200, 110 )'
        ( 150, 60 )

        $ c 'midpt_between_points( 100, 10, 50, 200, 110, 150 )'
        ( 150, 60, 100 )

- `angle_between_points`

    angle\_between\_points( _X1_, _Y1_, _X2_, _Y2_ \[, _IS\_AZIMUTH_ \] ) or angle\_between\_points( _X1_, _Y1_, _Z1_, _X2_, _Y2_, _Z2_ \[, _IS\_AZIMUTH_ \] ).
    Returns the angle from (_X1_,_Y1_) to (_X2_,_Y2_) or the horizontal and vertical angles from (_X1_,_Y1_,_Z1_) to (_X2_,_Y2_,_Z2_).
    Angles are in degrees.
    Returns the standard mathematical angle (0 degrees = East, counter-clockwise).
    If _IS\_AZIMUTH_ is set to true, the horizontal angle is returned (0 degrees = north, clockwise).
    alias: angle().

        $ c 'angle_between_points( 100, 10, 150, 110 )'
        63.434948822922

        $ c 'angle_between_points( 100, 10, 50, 150, 110, 150 )'
        ( 63.434948822922, 41.8103148957786 )

    _IS\_AZIMUTH_ is set to true

        $ c 'angle_between_points( 100, 10, 150, 110, 1 )'
        26.565051177078

        $ c 'angle_between_points( 100, 10, 50, 150, 110, 150, 1 )'
        ( 26.565051177078, 41.8103148957786 )

- `geo_radius`

    geo\_radius( _LAT_ ).
    Given a latitude (in radians),
    returns the distance from the center of the Earth to its surface (in meters).

    What is the radius of the equator (0 degrees latitude)?

        $ c 'geo_radius( deg2rad( 0 ) )'
        6378137   # 6,378,137 m

- `radius_of_lat`

    radius\_of\_lat( _LAT_ ).
    Given a latitude (in radians), returns the radius of that parallel (in meters).

    Radius of the parallel at 45 degrees latitude (distance of 1 radian):

        $ c 'radius_of_lat( deg2rad( 45 ) )'
        4517590.87888605  # 4,517,590.88 m

- `geo_distance`

    geo\_distance( _A\_LAT_, _A\_LON_, _B\_LAT_, _B\_LON_ ).
    Calculates and returns the distance (in meters) from _A_ to _B_.
    Latitude and longitude must be specified in radians.
    Same as geo\_distance\_m().

        $ TOKYO_ST='35.68129, 139.76706'
        $ OSAKA_ST='34.70248, 135.49595'
        $ c "geo_distance( deg2rad( $TOKYO_ST, $OSAKA_ST ) )"
        403054.141024738  # 403,054.14 m

- `geo_distance_m`

    geo\_distance\_m( _A\_LAT_, _A\_LON_, _B\_LAT_, _B\_LON_ ).
    Calculates and returns the distance (in meters) from _A_ to _B_.
    Latitude and longitude must be specified in radians.
    Same as geo\_distance().
    alias: gd\_m().

        $ TOKYO_ST='35.68129, 139.76706'
        $ OSAKA_ST='34.70248, 135.49595'
        $ c "geo_distance_m( deg2rad( $TOKYO_ST, $OSAKA_ST ) )"
        403054.141024738  # 403,054.11 m

- `geo_distance_km`

    geo\_distance\_km( _A\_LAT_, _A\_LON_, _B\_LAT_, _B\_LON_ ).
    Calculates and returns the distance (in kilometers) from _A_ to _B_.
    Latitude and longitude must be specified in radians.
    Same as geo\_distance\_m() / 1000.
    alias: gd\_km().

        $ TOKYO_ST='35.68129, 139.76706'
        $ OSAKA_ST='34.70248, 135.49595'
        $ c "geo_distance_km( deg2rad( $TOKYO_ST, $OSAKA_ST ) )"
        403.054141024738  # 403.05 km

- `geo_azimuth`

    geo\_azimuth( A\_LAT, A\_LON, B\_LAT, B\_LON ).
    Returns the geographic azimuth (bearing) in degrees from A to B.
    Note: 0 degrees is North, 90 degrees is East (clockwise).
    Input: Latitude/Longitude in radians.
    alias: gazm().

        $ c 'geo_azimuth( deg2rad( 35.68129, 139.76706 ), dms2rad( 33, 27, 56, 130, 10, 32 )  )'
        257.090172330251

- `geo_dist_m_and_azimuth`

    geo\_dist\_m\_and\_azimuth( A\_LAT, A\_LON, B\_LAT, B\_LON ).
    Returns the distance (in meters) and bearing (in degrees) from A to B.
    Latitude and longitude must be specified in radians.
    North is 0 degrees.
    alias: gd\_m\_azm().

        $ c 'geo_dist_m_and_azimuth( deg2rad( 35.68129, 139.76706 ), dms2rad( 33, 27, 56, 130, 10, 32 )  )'
        ( 911639.540768677, 257.090172330251 )    # 911,639.54 m ; 257 degrees

- `geo_dist_km_and_azimuth`

    geo\_dist\_km\_and\_azimuth( A\_LAT, A\_LON, B\_LAT, B\_LON ).
    Returns the distance (in kilometers) and bearing (in degrees) from A to B.
    Latitude and longitude must be specified in radians.
    North is 0 degrees.
    alias: gd\_km\_azm().

        $ c 'geo_dist_km_and_azimuth( deg2rad( 35.68129, 139.76706 ), dms2rad( 33, 27, 56, 130, 10, 32 )  )'
        ( 911.639540768677, 257.090172330251 )    # 911.64 km ; 257 degrees

- `is_leap`

    is\_leap( _YEAR1_ \[,.. \] ).
    Leap year test: Returns 1 if _YEAR_ is a leap year, 0 otherwise.

        $ c 'is_leap( 2024 )'
        1
        $ c 'is_leap( 2025 )'
        0

    Evaluate together:

        $ c 'is_leap( 1200, 1300, 1400, 1500, 1600, 1700, 1800, 1900, 2000, 2100 )'
        ( 1, 0, 0, 0, 1, 0, 0, 0, 1, 0 )

- `age_of_moon`

    age\_of\_moon( _Y_, _m_, _d_ ).
    Simple calculation of the age of the moon.
    Maximum deviation of about 2 days.

        $ c 'age_of_moon( 2025, 12, 5 )'
        15    # Moon's age is 15 days

    Today's Moon Age:

        $ c 'age_of_moon( slice( epoch2local( now ), 0, 3 ) )' -v
        epoch2local( 1764935943 ) = ( 2025, 12, 5, 20, 59, 3 )
        slice( 2025, 12, 5, 20, 59, 3, 0, 3 ) = ( 2025, 12, 5 )
        age_of_moon( 2025, 12, 5 ) = 15
        Formula: 'age_of_moon( slice( epoch2local( 1766677137 ), 0, 3 ) ) ='
            RPN: '# # # 1764935943 epoch2local 0 3 slice age_of_moon'
         Result: 15

- `local2epoch`

    local2epoch( _Y_, _m_, _d_ \[, _H_, _M_, _S_ \] ).
    Returns the local time in seconds since the epoch.
    alias: l2e().

        $ c 'local2epoch( 2025, 1, 2, 03, 40, 50 )'
        1735756850

- `gmt2epoch`

    gmt2epoch( _Y_, _m_, _d_ \[, _H_, _M_, _S_ \] ).
    Returns the GMT time in seconds since the epoch.
    alias: g2e().

        $ c 'gmt2epoch( 2025, 1, 1, 18, 40, 50 )'
        1735756850

- `epoch2local`

    epoch2local( _EPOCH_ ).
    Returns the local time.
    ( _Y_, _m_, _d_, _H_, _M_, _S_ ).
    alias: e2l().

        $ c 'epoch2local( 1735756850 )'
        ( 2025, 1, 2, 3, 40, 50 )     # 2025-01-02 03:40:50 LOCAL(JST)

- `epoch2gmt`

    epoch2gmt( _EPOCH_ ).
    Returns the GMT time.
    ( _Y_, _m_, _d_, _H_, _M_, _S_ ).
    alias: e2g().

        $ c 'epoch2gmt( 1735756850 )'
        ( 2025, 1, 1, 18, 40, 50 )    # 2025-01-01 18:40:50 GMT

- `sec2dhms`

    sec2dhms( _SECOND_ ) --Convert-to--> ( _D_, _H_, _M_, _S_ ).

        $ c 'sec2dhms( 356521 )'
        ( 4, 3, 2, 1 )    # 4 days, 3 hours, 2 minutes and 1 second

- `dhms2sec`

    dhms2sec( _D_ \[, _H_, _M_, _S_ \] ) --Convert-to--> ( _SECOND_ ).

        $ c 'dhms2sec( 4, 03, 02, 01 )'
        356521            # 356,521 seconds

- `ri2meter`

    ri2meter( RI ) --Convert-to--> METER.
    alias: 里→メートル(), 里２メートル().

        $ c 'ri2meter( 1 )'
        3927.2727272727

- `meter2ri`

    meter2ri( METER ) --Convert-to--> RI.
    alias: メートル→里(), メートル２里().

        $ c 'meter2ri( 4000 )'
        1.01851851851853

- `mile2meter`

    mile2meter( MILE ) --Convert-to--> METER.
    alias: マイル→メートル(), マイル２メートル().

        $ c 'mile2meter( 1 )'
        1609.344

- `meter2mile`

    meter2mile( METER ) --Convert-to--> MILE.
    alias: メートル→マイル(), メートル２マイル().

        $ c 'meter2mile( 2000 )'
        1.24274238447467

- `nautical_mile2meter`

    nautical\_mile2meter( NAUTICAL\_MILE ) --Convert-to--> METER.
    alias: 海里→メートル(), 海里２メートル().

        $ c 'nautical_mile2meter( 1 )'
        1852

- `meter2nautical_mile`

    meter2nautical\_mile( METER ) --Convert-to--> NAUTICAL\_MILE.
    alias: メートル→海里(), メートル２海里().

        $ c 'meter2nautical_mile( 2000 )'
        1.07991360691145

- `pound2gram`

    pound2gram( POUND ) --Convert-to--> GRAM.
    alias: ポンド→グラム(), ポンド２グラム().

        $ c 'pound2gram( 1 )'
        453.59237

- `gram2pound`

    gram2pound( GRAM ) --Convert-to--> POUND.
    alias: グラム→ポンド(), グラム２ポンド().

        $ c 'gram2pound( 500 )'
        1.10231131092439

- `ounce2gram`

    ounce2gram( OUNCE ) -->Convert-to--> GRAM.
    alias: オンス→グラム(), オンス２グラム().

        $ c 'ounce2gram( 1 )'
        28.349523125

- `gram2ounce`

    gram2ounce( GRAM ) -->Convert-to--> OUNCE.
    alias: グラム→オンス(), グラム２オンス().

        $ c 'gram2ounce( 30 )'
        1.05821885848741

- `laptimer`

    laptimer( _LAPS_ ).
    Each time you press Enter,
    the split time is measured and the time taken to measure _LAPS_ is returned.
    If _LAPS_ is set to a negative value, the split time is not output.
    alias: lt().

    The time for 3 laps was measured:

        $ c 'laptimer( 3 )'
        Lap  Split-Time    Lap-Time      Date-Time
        ---  ------------  ------------  -------------------
        <-- Enter key
        1/3  00:00:19.785  00:00:19.785  2025-12-17 22:18:29
        <-- Enter key
        2/3  00:00:39.562  00:00:19.777  2025-12-17 22:18:49
        <-- Enter key
        3/3  00:00:59.892  00:00:20.330  2025-12-17 22:19:09
        59.8917651176453

- `timer`

    timer( _SECOND_ ).
    If you specify a value less than 31536000 (365 days x 86400 seconds) for _SECOND_,
    the countdown will begin and end when it reaches zero.
    If you specify a value greater than this,
    it will be recognized as an epoch second,
    and the countdown or countup will begin with that date and time as zero.
    In this case, the countup will continue without stopping at zero.
    In either mode, press Enter to end.

    Specify the seconds in _SECOND_:

        $ c 'timer( 10 )'
        2025-12-27 06:02:58.002  TARGET
        2025-12-27 06:02:58.017    <-- 10 seconds have passed or press Enter
        0.0172009468078613    # Number of seconds from the TARGET time

    Specify the epoch second in _SECOND_: ( Dates before 1971 cannot be specified )

        $ c 'timer( local2epoch( 2025, 12, 27, 06, 07, 00 ) )'
        2025-12-27 06:07:00.222  TARGET
        00:00:15.150    <-- Enter key
        2025-12-27 06:07:15.236
        15.2361481189728      # Number of seconds from the TARGET time

- `stopwatch`

    stopwatch().
    Measures the time until the Enter key is pressed.
    The measured time is displayed on the screen.
    alias: sw().

    Usage example:

        $ c 'stopwatch()'
        <-- Enter key
        2025-11-25 01:53:17
        stopwatch() = 10.2675848007202 sec.
        10.2675848007202

- `bpm`

    bpm( _COUNT_, _SECOND_ ).
    Specify the number of beats as _COUNT_ and the elapsed time as _SECOND_ to calculate the BPM.

        $ c 'bpm( 4, sw() )'
        <-- Enter key
        2025-11-25 01:53:17
        stopwatch() = 2.15290594100952 sec.
        111.477234294528

- `bpm15`

    bpm15().
    Once you have confirmed 15 beats, press the Enter key.
    The BPM will be calculated from the elapsed time.
    The measured time is displayed on the screen.

        $ c 'bpm15()'
        <-- Enter key
        2025-11-25 01:53:17
        stopwatch() = 12.7652950286865 sec.
        70.5036583939106

- `bpm30`

    bpm30().
    Once you have confirmed 30 beats, press the Enter key.
    The BPM will be calculated from the elapsed time.
    The measured time is displayed on the screen.

        $ c 'bpm30()'
        <-- Enter key
        2025-11-25 01:53:17
        stopwatch() = 24.9058220386505 sec.
        72.2722581574156

- `tachymeter`

    tachymeter( _SECOND_ ).
    Returns the number of units of work that can be completed per hour,
    where _SECOND_ is the number of seconds required to complete one unit of work.
    Same as ratio\_scaling( _SECOND_, 1, 3600 ).

    Measure the time for a 1km section and calculate the speed:

        $ c 'tachymeter( sw() )'
        <-- Enter key
        2025-11-25 01:53:17
        stopwatch() = 35.5551850795746 sec.
        101.251054999235  # 101 km/h

- `telemeter`

    telemeter( _SECOND_ ).
    Measures distance using the difference in the speed of light and sound.
    Returns the distance equivalent to _SECOND_ in meters.
    Same as telemeter\_m().

        $ c 'telemeter( sw() )'
        <-- Enter key
        2025-11-25 01:53:17
        stopwatch() = 7.9051628112793 sec.
        2687.75535583496  # 2687.76 m

- `telemeter_m`

    telemeter\_m( _SECOND_ ).
    Measures distance using the difference in the speed of light and sound.
    Returns the distance equivalent to _SECOND_ in meters.
    Same as telemeter().

        $ c 'telemeter_m( 8 )'
        2720  # 2720 m

- `telemeter_km`

    telemeter\_km( _SECOND_ ).
    Measures distance using the difference in the speed of light and sound.
    Returns the distance equivalent to _SECOND_ in kilometers.
    Same as telemeter\_m() / 1000.

        $ c 'telemeter_km( 8 )'
        2.72  # 2.72 km

# DEPENDENCIES

This script uses only **core Perl modules**. No external modules from CPAN are required.

## Core Modules Used

- base - first included in perl 5.00405
- Class::Struct — first included in perl 5.004
- constant — first included in perl 5.004
- Encode — first included in perl v5.7.3
- File::Basename — first included in perl 5
- List::Util — first included in perl v5.7.3
- Math::BigInt — first included in perl 5
- Math::Trig — first included in perl 5.004
- POSIX — first included in perl 5
- strict — first included in perl 5
- Time::HiRes - first included in perl v5.7.3
- Time::Local - first included in perl 5
- utf8 — first included in perl v5.6.0
- warnings — first included in perl v5.6.0

## Survey methodology

- 1. Preparation

    Define the script name:

        $ target_script=c

- 2. Extract used modules

    Generate a list of modules from `use` statements:

        $ grep '^use ' $target_script | sed 's!^use \([^ ;{][^ ;{]*\).*$!\1!' | \
            sort | uniq | tee ${target_script}.uselist

- 3. Check core module status

    Run `corelist` for each module to find the first Perl version it appeared in:

        $ cat ${target_script}.uselist | while read line; do
            corelist $line
          done

# SEE ALSO

- [perl](https://metacpan.org/pod/perl)(1)
- [List::Util](https://metacpan.org/pod/List%3A%3AUtil)
- [Math::BigInt](https://metacpan.org/pod/Math%3A%3ABigInt)
- [Math::Trig](https://metacpan.org/pod/Math%3A%3ATrig)
- [POSIX](https://metacpan.org/pod/POSIX)
- [Time::HiRes](https://metacpan.org/pod/Time%3A%3AHiRes)
- [Time::Local](https://metacpan.org/pod/Time%3A%3ALocal)

# AUTHOR

2025-2026, tomyama

# LICENSE

Copyright (c) 2025-2026, tomyama

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1\. Redistributions of source code must retain the above copyright notice,
   this list of conditions and the following disclaimer.

2\. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3\. Neither the name of tomyama nor the names of its contributors
   may be used to endorse or promote products derived from this software
   without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

* * *
- See '[README.md](../README.md)' for installation instructions.
- See '[CATALOG.md](CATALOG.md)' for a list and overview of the scripts.
